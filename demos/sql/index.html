<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SQL — Modèle, requêtes, qualité & pipeline | Hestia Aura</title>

  <link rel="icon" href="/assets/logo.jpg" />
  <link rel="apple-touch-icon" href="/assets/logo.jpg" />
  <link rel="stylesheet" href="/styles.css?v=final3" />

  <!-- SEO -->
  <meta name="description" content="Exemples SQL Server : modèle relationnel, KPIs mensuels, optimisation de requêtes (sargable), contrôles qualité et journal de pipeline." />
  <meta property="og:title" content="Showcase SQL — Hestia Aura" />
  <meta property="og:description" content="Modélisation, performance de requêtes, qualité des données et pipeline SQL léger sur un jeu e-commerce fictif." />
  <meta property="og:image" content="/assets/logo.jpg" />
</head>

<!-- on réutilise les styles capsules/zoom déjà définis dans styles.css -->
<body class="powerbi">
  <!-- EN-tête commun -->
  <header class="site-header">
    <div class="container header-inner">
      <a class="brand" href="/">
        <img src="/assets/logo.jpg" class="brand-mark" alt="logo" />
        <span class="brand-name">Hestia <strong>Aura</strong></span>
      </a>
      <nav class="nav">
        <a href="/">Accueil</a>
        <a href="/about.html">À propos</a>
        <a href="/showcase.html">Showcase</a>
        <a class="btn btn--sm" href="/en/demos/sql/">EN</a>
      </nav>
    </div>
  </header>

  <main id="main">
    <!-- HERO -->
    <section class="hero">
      <div class="container">
        <h1>SQL — Modèle, requêtes, qualité & pipeline</h1>

        <p>
          Exemples pédagogiques sur un jeu e-commerce fictif (CH/EU) couvrant 2019–2024.
          L’idée n’est pas de « montrer une stack », mais d’illustrer **ce que l’on peut faire avec SQL** :
          bâtir un modèle simple, produire des agrégats lisibles, lire un plan d’exécution pour
          optimizer une requête (<em>sargable</em>), vérifier la **qualité des données** et suivre un
          **pipeline** en production légère.
        </p>

        <div class="pills">
          <span class="pill">SQL Server</span>
          <span class="pill">SSMS</span>
          <span class="pill">ETL</span>
          <span class="pill">Data Quality</span>
        </div>

        <p style="margin-top:12px;">
          <a class="btn btn--sm btn--primary" href="/showcase.html">↩ Retour au Showcase</a>
        </p>

        <ul class="hero-badges" style="margin-top:8px">
          <li><a href="#p1">P1 — Modèle & KPI</a></li>
          <li><a href="#p2">P2 — Requêtes optimisées</a></li>
          <li><a href="#p3">P3 — Qualité des données</a></li>
          <li><a href="#p4">P4 — Pipeline & journal</a></li>
        </ul>
      </div>
    </section>

    <!-- P1 -->
    <section id="p1" class="section">
      <div class="container">
        <h2>P1 — Modélisation & requêtes métier</h2>

        <div class="capsule capsule--lr">
          <figure class="capsule-media figure">
            <img src="/assets/media/SQL_P1_ERD.jpg" alt="Schéma relationnel SQL (customers, orders, order_items, products, payments)" />
            <figcaption>Schéma logique : <strong>customers</strong> → <strong>orders</strong> → <strong>order_items</strong>, avec <strong>products</strong> et <strong>payments</strong>.</figcaption>
          </figure>

          <div class="capsule-body">
            <h3>Contexte & objectifs</h3>
            <p>
              On part d’un **modèle relationnel minimal** pour illustrer ce que l’on peut faire avec SQL :
              requêtes claires, indicateurs mensuels, et résultats réutilisables pour un tableau de bord.
              On s’appuie sur des types explicites, des clés primaires/étrangères et des contraintes
              simples (<code>NOT NULL</code>, <code>CHECK</code>).
            </p>
            <p>
              Côté requêtes, on combine des CTE (<code>WITH</code>) et quelques **fonctions de fenêtre**
              (ex. <code>SUM() OVER</code>) pour agréger proprement. Les agrégats cibles :
              **CA (CHF)**, **nombre de commandes**, **panier moyen** et **clients actifs** par mois.
            </p>

            <h4>Agrégats mensuels (extrait)</h4>
            <figure class="figure">
              <img src="/assets/media/SQL_P1_KPI.jpg" alt="Revenus mensuels, commandes, panier moyen, clients actifs" />
              <figcaption>
                Vue « sales_monthly » : **revenue_chf**, **orders_cnt**, **avg_order_value**, **active_customers** (mois).
              </figcaption>
            </figure>
          </div>
        </div>
      </div>
    </section>

    <!-- P2 -->
    <section id="p2" class="section">
      <div class="container">
        <h2>P2 — Performance & indexation (lecture de plans)</h2>

        <div class="capsule">
          <p>
            L’idée est de **réécrire** une requête pour la rendre <em>sargable</em> (search-ARGument-able)
            et **exploiter un index** pertinent. Ici, la requête « Top clients sur période » était écrite
            avec une fonction sur la colonne de date : l’optimiseur scannait plus que nécessaire.
          </p>

          <div class="capsule--lr">
            <figure class="capsule-media figure figure--plan">
              <img src="/assets/media/SQL_P2_BEFORE.jpg" alt="Plan d'exécution avant — requête non sargable" data-zoom="1" />
              <figcaption>
                <strong>Avant</strong> : filtre non sargable (<code>CONVERT(date,o.order_date)</code>), l’index ne peut pas être utilisé efficacement → **scan** inutilement large.
              </figcaption>
            </figure>

            <div class="capsule-body">
              <figure class="figure figure--plan">
                <img src="/assets/media/SQL_P2_AFTER.jpg" alt="Plan d'exécution après — requête sargable et index utilisé" data-zoom="1" />
                <figcaption>
                  <strong>Après</strong> : bornes directes sur la colonne indexée
                  (<code>o.order_date &gt;= '2021-01-01' AND o.order_date &lt; '2023-01-01'</code>) +
                  index composé (<code>order_date, customer_id</code>) : plan plus léger, tri plus économique.
                </figcaption>
              </figure>

              <p class="muted" style="margin-top:6px">
                Bonnes pratiques : limiter les colonnes sélectionnées, préférer <code>EXISTS</code> à
                <code>IN</code> quand utile, pré-agréger si nécessaire, et **lire le plan** (coûts, opérateurs).
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- P3 -->
    <section id="p3" class="section">
      <div class="container">
        <h2>P3 — Qualité & fiabilité des données</h2>

        <div class="capsule capsule--lr">
          <figure class="capsule-media figure">
            <img src="/assets/media/SQL_P3_QUALITY.jpg" alt="Vue de synthèse des contrôles qualité : doublons, valeurs nulles, paiements négatifs, références manquantes" />
            <figcaption>
              Vue de synthèse : **règle**, **sévérité** (high/medium/low), **lignes affectées** — triée par priorité.
            </figcaption>
          </figure>

          <div class="capsule-body">
            <p>
              Voici **ce que l’on peut faire avec SQL** pour fiabiliser un jeu de données : règles
              de qualité (doublons, <code>NULL</code>, références orphelines, montants négatifs), mise en
              forme homogène et **priorisation** des corrections. Une **vue** consolide les résultats
              pour les exposer à un tableau de bord ou à des notifications.
            </p>
            <ul>
              <li>Règles simples et explicites (clé composite, contraintes <code>CHECK</code>).</li>
              <li>Priorisation par sévérité pour traiter d’abord l’impact métier.</li>
              <li>Exemples de corrections possibles (UPDATE/DELETE sécurisés).</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- P4 -->
    <section id="p4" class="section">
      <div class="container">
        <h2>P4 — ETL SQL léger & journal d’exécution</h2>

        <div class="capsule capsule--lr">
          <figure class="capsule-media figure">
            <img src="/assets/media/SQL_P4_PIPELINE.png" alt="Schéma pipeline : staging → clean → mart avec audit" />
            <figcaption>
              Pipeline logique : **staging** (brut) → **clean** (normalisé) → **mart** (pour la BI) +
              zone **audit** (journal & qualité).
            </figcaption>
          </figure>

          <div class="capsule-body">
            <p>
              Un flux SQL « léger » reste lisible et **idempotent** : chargements
              incrémentaux, **MERGE/UPSERT**, clés techniques, horodatage. La planification peut se
              faire via CRON/Azure DevOps à 08:30 CET, avec relance en cas d’échec.
            </p>

            <figure class="figure">
              <img src="/assets/media/SQL_P4_JOBS.jpg" alt="Journal des exécutions : jobs, timestamps, statuts, volumes, message" />
              <figcaption>
                Journal des jobs (<code>job_runs</code>) : <em>start/end-ts</em>, <em>status</em>, <em>rows_in/out</em>,
                <em>message</em>. Exemple pédagogique : ré-exécution après correction, contrainte
                sur paiement négatif, delta import, etc.
              </figcaption>
            </figure>

            <p class="muted">
              Sortie attendue : un pipeline simple, observable et traçable, prêt à être branché
              sur un dashboard opérationnel.
            </p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Pied de page -->
  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="y"></span> Jérôme Jeannin</span>
      <a href="mailto:contact@hestiaaura.com">contact@hestiaaura.com</a>
    </div>
  </footer>

  <!-- App + Lightbox -->
  <script src="/app.js?v=final3"></script>

  <!-- Modale d'image (zoom plein écran) -->
  <div class="image-modal" id="imgModal" aria-hidden="true">
    <button class="close" id="imgModalClose" aria-label="Fermer l’image">✕</button>
    <img id="imgModalImg" alt="" />
  </div>

  <script>
    // Année footer
    (function(){var y=document.getElementById('y'); if(y){ y.textContent=new Date().getFullYear(); }})();

    // Zoom images (toutes les <img> dans .figure)
    (function(){
      const modal   = document.getElementById('imgModal');
      const modalImg= document.getElementById('imgModalImg');
      const close   = document.getElementById('imgModalClose');
      if(!modal || !modalImg || !close) return;

      document.addEventListener('click', function(e){
        const img = e.target.closest('.figure img');
        if(!img) return;
        modalImg.src = img.src;
        modal.classList.add('open');
        modal.setAttribute('aria-hidden','false');
      });

      function hide(){
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden','true');
        modalImg.src = '';
      }
      close.addEventListener('click', hide);
      modal.addEventListener('click', function(e){ if(e.target === modal) hide(); });
      document.addEventListener('keydown', function(e){ if(e.key === 'Escape') hide(); });
    })();
  </script>
</body>
</html>
