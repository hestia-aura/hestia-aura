<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SQL — Modèle, requêtes, qualité & pipeline | Hestia Aura</title>

  <link rel="icon" href="/assets/logo.jpg" />
  <link rel="apple-touch-icon" href="/assets/logo.jpg" />
  <link rel="stylesheet" href="/styles.css?v=final3" />

  <meta name="description" content="Exemples SQL Server : modèle relationnel, KPIs mensuels, optimisation de requêtes (sargable), contrôles qualité et journal de pipeline." />
  <meta property="og:title" content="Showcase SQL — Hestia Aura" />
  <meta property="og:description" content="Modélisation, performance de requêtes, qualité des données et pipeline SQL léger sur un jeu e-commerce fictif." />
  <meta property="og:image" content="/assets/logo.jpg" />
</head>

<body class="powerbi">
  <header class="site-header">
    <div class="container header-inner">
      <a class="brand" href="/">
        <img src="/assets/logo.jpg" class="brand-mark" alt="logo" />
        <span class="brand-name">Hestia <strong>Aura</strong></span>
      </a>
      <nav class="nav">
        <a href="/">Accueil</a>
        <a href="/about.html">À propos</a>
        <a href="/showcase.html">Showcase</a>
        <a class="btn btn--sm" href="/en/demos/sql/">EN</a>
      </nav>
    </div>
  </header>

  <main id="main">
    <!-- HERO -->
    <section class="hero">
      <div class="container">
        <h1>SQL — Modèle, requêtes, qualité & pipeline</h1>

        <p>
          Exemples pédagogiques sur un jeu e-commerce fictif (CH/EU) couvrant 2019–2024.
          L’idée n’est pas de « montrer une stack », mais d’illustrer
          <strong>ce que l’on peut faire avec SQL</strong> : bâtir un modèle simple, produire des agrégats lisibles,
          lire un plan d’exécution pour optimiser une requête (<em>sargable</em>), vérifier la
          <strong>qualité des données</strong> et suivre un <strong>pipeline</strong> en production légère.
        </p>

        <div class="pills">
          <span class="pill">SQL Server</span>
          <span class="pill">SSMS</span>
          <span class="pill">ETL</span>
          <span class="pill">Data Quality</span>
        </div>

        <p style="margin-top:12px;">
          <a class="btn btn--sm btn--primary" href="/showcase.html">↩ Retour au Showcase</a>
        </p>

        <ul class="hero-badges" style="margin-top:8px">
          <li><a href="#p1">P1 — Modèle & KPI</a></li>
          <li><a href="#p2">P2 — Requêtes optimisées</a></li>
          <li><a href="#p3">P3 — Qualité des données</a></li>
          <li><a href="#p4">P4 — Pipeline & journal</a></li>
        </ul>
      </div>
    </section>

    <!-- P1 -->
    <section id="p1" class="section">
      <div class="container">
        <h2>P1 — Modélisation & requêtes métier</h2>

        <div class="capsule capsule--lr">
          <figure class="capsule-media figure">
            <img src="/assets/media/SQL_P1_ERD.jpg" alt="Schéma relationnel SQL (customers, orders, order_items, products, payments)" />
            <figcaption>Schéma logique : <strong>customers</strong> → <strong>orders</strong> → <strong>order_items</strong>, avec <strong>products</strong> et <strong>payments</strong>.</figcaption>
          </figure>

          <div class="capsule-body">
            <h3>Contexte & objectifs</h3>
            <p>
              On part d’un <strong>modèle relationnel minimal</strong> pour illustrer ce que l’on peut faire avec SQL :
              requêtes claires, indicateurs mensuels, et résultats réutilisables pour un tableau de bord.
              On s’appuie sur des types explicites, des clés primaires/étrangères et des contraintes simples
              (<code>NOT NULL</code>, <code>CHECK</code>).
            </p>
            <p>
              Côté requêtes, on combine des CTE (<code>WITH</code>) et quelques
              <strong>fonctions de fenêtre</strong> (ex. <code>SUM() OVER</code>) pour agréger proprement.
              Les agrégats cibles : <strong>CA (CHF)</strong>, <strong>nombre de commandes</strong>,
              <strong>panier moyen</strong> et <strong>clients actifs</strong> par mois.
            </p>

            <h4>Agrégats mensuels (extrait)</h4>
            <figure class="figure">
              <img src="/assets/media/SQL_P1_KPI.jpg" alt="Revenus mensuels, commandes, panier moyen, clients actifs" />
              <figcaption>
                Vue « sales_monthly » : <strong>revenue_chf</strong>, <strong>orders_cnt</strong>,
                <strong>avg_order_value</strong>, <strong>active_customers</strong> (mois).
              </figcaption>
            </figure>
          </div>
        </div>
      </div>
    </section>

    <!-- P2 -->
    <section id="p2" class="section">
      <div class="container">
        <h2>P2 — Performance & indexation (lecture de plans)</h2>

        <div class="capsule">
          <p>
            L’objectif : <strong>réécrire</strong> une requête pour la rendre <em>sargable</em>
            (search-ARGument-able) et <strong>exploiter un index</strong> pertinent.
            Ici, la requête « Top clients sur période » appliquait une fonction sur la colonne de date :
            l’optimiseur scannait plus que nécessaire.
          </p>

          <div class="capsule--lr">
            <figure class="capsule-media figure figure--plan">
              <img src="/assets/media/SQL_P2_BEFORE.jpg" alt="Plan d'exécution avant — requête non sargable" data-zoom="1" />
              <figcaption>
                <strong>Avant</strong> : filtre non sargable (<code>CONVERT(date, o.order_date)</code>),
                l’index ne peut pas être utilisé efficacement → scan inutilement large.
              </figcaption>
            </figure>

            <div class="capsule-body">
              <figure class="figure figure--plan">
                <img src="/assets/media/SQL_P2_AFTER.jpg" alt="Plan d'exécution après — requête sargable et index utilisé" data-zoom="1" />
                <figcaption>
                  <strong>Après</strong> : bornes directes sur la colonne indexée
                  (<code>o.order_date &gt;= '2021-01-01' AND o.order_date &lt; '2023-01-01'</code>) +
                  index composé (<code>order_date, customer_id</code>) : plan plus léger, tri plus économique.
                </figcaption>
              </figure>

              <p class="muted" style="margin-top:6px">
                Bonnes pratiques : limiter les colonnes sélectionnées, préférer <code>EXISTS</code> à
                <code>IN</code> quand utile, pré-agréger si nécessaire, et <strong>lire le plan</strong>
                (coûts, opérateurs).
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- P3 -->
    <section id="p3" class="section">
      <div class="container">
        <h2>P3 — Qualité & fiabilité des données</h2>

        <div class="capsule capsule--lr">
          <figure class="capsule-media figure">
            <img src="/assets/media/SQL_P3_QUALITY.jpg" alt="Vue de synthèse des contrôles qualité : doublons, valeurs nulles, paiements négatifs, références manquantes" />
            <figcaption>
              Vue de synthèse : <strong>règle</strong>, <strong>sévérité</strong> (high/medium/low),
              <strong>lignes affectées</strong> — triée par priorité.
            </figcaption>
          </figure>

          <div class="capsule-body">
            <p>
              Voici <strong>ce que l’on peut faire avec SQL</strong> pour fiabiliser un jeu de données :
              règles de qualité (doublons, <code>NULL</code>, références orphelines, montants négatifs),
              mise en forme homogène et <strong>priorisation</strong> des corrections.
              Une <strong>vue</strong> consolide les résultats pour les exposer à un tableau de bord
              ou à des notifications.
            </p>
            <ul>
              <li>Règles simples et explicites (clé composite, contraintes <code>CHECK</code>).</li>
              <li>Priorisation par sévérité pour traiter d’abord l’impact métier.</li>
              <li>Exemples de corrections possibles (UPDATE/DELETE sécurisés).</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <!-- P4 -->
    <section id="p4" class="section">
      <div class="container">
        <h2>P4 — ETL SQL léger & journal d’exécution</h2>

        <div class="capsule capsule--lr">
          <figure class="capsule-media figure">
            <img src="/assets/media/SQL_P4_PIPELINE.png" alt="Schéma pipeline : staging → clean → mart avec audit" />
            <figcaption>
              Pipeline logique : <strong>staging</strong> (brut) → <strong>clean</strong> (normalisé) → <strong>mart</strong> (pour la BI)
              + zone <strong>audit</strong> (journal & qualité).
            </figcaption>
          </figure>

          <div class="capsule-body">
            <p>
              Un flux SQL « léger » reste lisible et <strong>idempotent</strong> : chargements incrémentaux,
              <strong>MERGE/UPSERT</strong>, clés techniques, horodatage. La planification peut se faire via
              CRON/Azure DevOps à 08:30 CET, avec relance en cas d’échec.
            </p>

            <figure class="figure">
              <img src="/assets/media/SQL_P4_JOBS.jpg" alt="Journal des exécutions : jobs, timestamps, statuts, volumes, message" />
              <figcaption>
                Journal des jobs (<code>job_runs</code>) : start/end-ts, status, rows_in/out, message.
                Exemple pédagogique : ré-exécution après correction, contrainte sur paiements négatifs, delta import, etc.
              </figcaption>
            </figure>

            <p class="muted">
              Sortie attendue : un pipeline simple, observable et traçable, prêt à être branché
              sur un dashboard opérationnel.
            </p>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <span>© <span id="y"></span> Jérôme Jeannin</span>
      <a href="mailto:contact@hestiaaura.com">contact@hestiaaura.com</a>
    </div>
  </footer>

  <script src="/app.js?v=final3"></script>

  <!-- Modale d'image (zoom plein écran) -->
  <div class="image-modal" id="imgModal" aria-hidden="true">
    <button class="close" id="imgModalClose" aria-label="Fermer l’image">✕</button>
    <img id="imgModalImg" alt="" />
  </div>

  <script>
    // Année footer
    (function(){var y=document.getElementById('y'); if(y){ y.textContent=new Date().getFullYear(); }})();

    // Zoom images
    (function(){
      const modal   = document.getElementById('imgModal');
      const modalImg= document.getElementById('imgModalImg');
      const close   = document.getElementById('imgModalClose');
      if(!modal || !modalImg || !close) return;

      document.addEventListener('click', function(e){
        const img = e.target.closest('.figure img');
        if(!img) return;
        modalImg.src = img.src;
        modal.classList.add('open');
        modal.setAttribute('aria-hidden','false');
      });

      function hide(){
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden','true');
        modalImg.src = '';
      }
      close.addEventListener('click', hide);
      modal.addEventListener('click', function(e){ if(e.target === modal) hide(); });
      document.addEventListener('keydown', function(e){ if(e.key === 'Escape') hide(); });
    })();
  </script>
</body>
</html>
